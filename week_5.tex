\documentclass{article}
\usepackage{xeCJK}
\usepackage{amsmath,esint,amssymb,amsthm}
\usepackage{algorithmic}
\usepackage{algorithm}
\newtheorem{remark}{remark}
\begin{document}
\title{第五周作业}
\author{赵丰，2017310711}
\maketitle

\textbf{Ch4.7}

\begin{remark}
$p_i$没有用
\end{remark}
此题与\textbf{Ch4.6}的贪心策略相同，按$f_i$从大到小排序，超级计算机优先$f_i$大的作业，该算法可以返回一个最小完成时间的调度。
论证与\textbf{Ch4.6}相同。

\textbf{Ch4.13}
%优先完成时间短且权值高的作业。
我们只需考虑所有方案中完成作业不存在时间间隔的方案。
定义作业单位时间的权重$f_i=\frac{w_i}{t_i}$,按$f_i$从大到小排序，优先$f_i$大的作业，可以得到一个完成时间的带权和
$\displaystyle\sum_{i=1}^n w_i C_i$达到最小的调度方案。

如果一个方案中存在作业$i$和$j$，$i$排在$j$的前面但$f_i<f_j$，则总可以
找到相邻的两个作业也满足同样的关系。
根据我们的贪心模板，我们只需说明对于相邻的两个作业$i$和$j$,如果$f_i$更大，
那么作业$i$放在作业$j$的前面可以降低完成时间的带权和。

注意到$i$和$j$孰先孰后对其他作业的权值$C_k$没有影响，因此我们只需比较$w_i C_{if}+w_j C_{jb}$（$i$在前）与
$w_j C_{jf}+w_i C_{ib}$（$j$在前），其中$C_i$的第二个下标的含义分别表示$i$相对于$j$是front还是back.如果将待比较的式子两边去掉
之前的时间，只需比较$w_i t_i+w_j (t_i+t_j)$与 $w_j t_j+w_i (t_i+t_j)$,两边消去公共项，只需比较：
$w_j t_i$与 $w_i t_j$，
由于$f_i>f_j$，所以$w_i t_j > w_j t_i$ ，因此$i$在前总完成时间的带权和更小。即我们证明了作业$i$放在作业$j$的前面可以降低完成时间的带权和
这一结论。

\textbf{Ch4.5}
假设各房子均分布在一条道路（线段）上，
取数轴的原点在该道路的西端点，而东端点坐标为$T$,
并且房子的坐标集合为$S=\{x_1,x_2,\dots,x_n\}$,且满足序关系:
$x_i\leq x_j \iff i\leq j$
下面给出一种贪心策略进行基站布署。
首先在$x_1+4$处布置一个基站，之后寻找最小的$i_2$，使得$x_1+8\leq x_{i_2}$,
再在$x_{i_2}+4$处布置第二个基站，依此类推，直到布置了第$k$个基站后找不到$r$，使得
$x_{i_k}+8\leq x_r$。

下面我们说明从一个具有最少基站布署的配置$C'$出发，通过调整基站的位置可以在不改变基站数目的条件下
化为我们的贪心算法给出的基站位置布置。
首先考虑 $C'$中覆盖$x_1$的基站$b_1$，
当我们把$b_1$调整到$x_1+4$位置时仍满足全覆盖的条件，
此时我们按照贪心算法可以找到$x_{i_2}$,
$b_1$无法覆盖$x_{i_2}$,因此可以在原基站配置中找到覆盖$x_{i_2}$的基站$b_2$，并且将$b_2$的位置
调整到$x_{i_2}+4$处仍满足全覆盖的条件。依此类推，可以得到我们的贪心算法给出的基站数目
小于等于$C'$中的基站数目，因为$C'$是具有最少基站布署的配置，因此我们的贪心算法在这一点上也是最优的。

\textbf{Ch4.18}
类似于Dijkstra算法，我们给出确定从始点到目的地的最短时间的算法：
\begin{algorithm}
\caption{以$s$为始点的最短时间算法}
\begin{algorithmic}[1]
\STATE 给图中每个节点一个距离函数$d$,$\,d(s)=0$,对其他点$d(u)=\infty$
\STATE 置$s$为当前节点，其他节点装入未访问的节点集$U$
\FOR{当前节点$v$在$U$中的每个邻居$c$}
\IF{$f_{(v,c)}(d(v))<d(c)$}
\STATE 置$c$的前一节点为$v$
\STATE $d(c)=f_{(v,c)}(d(v))$
\ENDIF
\ENDFOR
\STATE 当前节点$v$加入被访问的节点集$V$
\IF{目标节点$t$在$V$中}
\STATE 顺次提取$t$的前一节点直到始点$s$得到路径$p$
\RETURN $p$
\ELSE 
\STATE 取出$U$中$d$最小的节点$v'$设为当前节点,$U$中去掉$v'$
\ENDIF
\end{algorithmic}
\end{algorithm}

由于$d(v)\leq f_{(v,c)}(d(v))<d(c)$,所以每条边的动态权值虽然和始点有关但仍为非负。
$f(t)$的单调增的特性保证了不可以通过原地等待的方式减少每条边的动态权值，所以唯一有效的方式即
为立即出发。

有了上面两点，仿照Dijkstra算法对于具有非负权值的连通图可以找到最短路径的论证过程容易说明
上面的方法对于有动态权值的图也可以给出最短时间。
%f(t) monotonic increasing, how to use?
\end{document}
